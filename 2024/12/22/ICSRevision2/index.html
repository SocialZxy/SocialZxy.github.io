<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":"flat","style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="链接 可重定位目标文件 符号解析 重定位 可执行目标文件 动态链接   异常控制流 异常 进程   系统级 I&#x2F;O 并发编程 基于进程的并发编程 基于 I&#x2F;O 多路复用的并发编程 基于线程的并发编程 线程同步和资源调度">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机系统小常识（下）">
<meta property="og:url" content="http://example.com/2024/12/22/ICSRevision2/index.html">
<meta property="og:site_name" content="Stellary&#39;s Notes">
<meta property="og:description" content="链接 可重定位目标文件 符号解析 重定位 可执行目标文件 动态链接   异常控制流 异常 进程   系统级 I&#x2F;O 并发编程 基于进程的并发编程 基于 I&#x2F;O 多路复用的并发编程 基于线程的并发编程 线程同步和资源调度">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/picture/FileKernelDS.jpg">
<meta property="og:image" content="http://example.com/picture/TrajectoryGraph.png">
<meta property="og:image" content="http://example.com/picture/Deadlock.png">
<meta property="article:published_time" content="2024-12-22T14:17:59.000Z">
<meta property="article:modified_time" content="2025-01-11T13:48:26.154Z">
<meta property="article:author" content="King Strange">
<meta property="article:tag" content="Linking">
<meta property="article:tag" content="Eception Control Flow">
<meta property="article:tag" content="Virtual Memory">
<meta property="article:tag" content="System Level IO">
<meta property="article:tag" content="Network">
<meta property="article:tag" content="Concurrent Programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/picture/FileKernelDS.jpg">


<link rel="canonical" href="http://example.com/2024/12/22/ICSRevision2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2024/12/22/ICSRevision2/","path":"2024/12/22/ICSRevision2/","title":"计算机系统小常识（下）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>计算机系统小常识（下） | Stellary's Notes</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Stellary's Notes</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-index"><a href="/index/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>index</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">链接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">可重定位目标文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">符号解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.3.</span> <span class="nav-text">重定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.4.</span> <span class="nav-text">可执行目标文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.5.</span> <span class="nav-text">动态链接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">异常控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.1.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.2.</span> <span class="nav-text">进程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">系统级 I&#x2F;O</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">4.1.</span> <span class="nav-text">基于进程的并发编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">4.2.</span> <span class="nav-text">基于 I&#x2F;O 多路复用的并发编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">4.3.</span> <span class="nav-text">基于线程的并发编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">4.4.</span> <span class="nav-text">线程同步和资源调度</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="King Strange"
      src="https://s2.loli.net/2023/11/24/rtCEFG1igyYAlm4.png">
  <p class="site-author-name" itemprop="name">King Strange</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">63</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SocialZxy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SocialZxy" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:stellary@stu.pku.edu.cn" title="E-Mail → mailto:stellary@stu.pku.edu.cn" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://hexo.io/" title="https:&#x2F;&#x2F;hexo.io" rel="noopener" target="_blank">Hexo</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://theme-next.js.org/" title="https:&#x2F;&#x2F;theme-next.js.org&#x2F;" rel="noopener" target="_blank">NexT</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://syksykccc.github.io/" title="https:&#x2F;&#x2F;syksykccc.github.io" rel="noopener" target="_blank">syksykCCC</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://blog.imyangty.com/" title="https:&#x2F;&#x2F;blog.imyangty.com" rel="noopener" target="_blank">YangTY's Blog - 越过山川</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://rpche-6626.github.io/" title="https:&#x2F;&#x2F;rpche-6626.github.io&#x2F;" rel="noopener" target="_blank">RPChe_6626</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/22/ICSRevision2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://s2.loli.net/2023/11/24/rtCEFG1igyYAlm4.png">
      <meta itemprop="name" content="King Strange">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellary's Notes">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="计算机系统小常识（下） | Stellary's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机系统小常识（下）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-12-22 22:17:59" itemprop="dateCreated datePublished" datetime="2024-12-22T22:17:59+08:00">2024-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-01-11 21:48:26" itemprop="dateModified" datetime="2025-01-11T21:48:26+08:00">2025-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Revision-Notes/" itemprop="url" rel="index"><span itemprop="name">Revision Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- toc -->

<ul>
<li><a href="#%E9%93%BE%E6%8E%A5">链接</a><ul>
<li><a href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6">可重定位目标文件</a></li>
<li><a href="#%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90">符号解析</a></li>
<li><a href="#%E9%87%8D%E5%AE%9A%E4%BD%8D">重定位</a></li>
<li><a href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6">可执行目标文件</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5">动态链接</a></li>
</ul>
</li>
<li><a href="#%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81">异常控制流</a><ul>
<li><a href="#%E5%BC%82%E5%B8%B8">异常</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B">进程</a></li>
</ul>
</li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E7%BA%A7-io">系统级 I&#x2F;O</a></li>
<li><a href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">并发编程</a><ul>
<li><a href="#%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">基于进程的并发编程</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">基于 I&#x2F;O 多路复用的并发编程</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">基于线程的并发编程</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6">线程同步和资源调度</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>

<h1><span id="链接">链接</span></h1><p><strong>编译的全过程</strong></p>
<ul>
<li><code>cpp</code> 预处理器，<code>main.cpp</code> $\rightarrow$ <code>main.i</code>（ASCII 中间文件）。</li>
<li><code>cc1</code> 编译器，<code>main.i</code> $\rightarrow$ <code>main.s</code>（ASCII 汇编语言文件）。</li>
<li><code>as</code> 汇编器，<code>main.s</code> $\rightarrow$ <code>main.o</code>（可重定位目标文件）。</li>
<li><code>ld</code> 静态链接器，<code>main.o</code>，<code>sum.o</code> $\rightarrow$ <code>prog</code>（可执行文件）。</li>
</ul>
<p>静态链接器需要完成以下两个任务：</p>
<ul>
<li><strong>符号解析</strong> 目标文件定义和引用了符号（函数、全局变量、静态变量等），符号解析将每个定义和引用联系在一起。</li>
<li><strong>重定位</strong> 编译器和汇编器生成地址从 $0$ 开始的数据和代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节。</li>
</ul>
<p>看到后面就知道具体是什么东西了。</p>
<hr>
<p><strong>目标文件</strong></p>
<p>分为</p>
<ul>
<li><strong>可重定位目标文件</strong>。包含二进制代码和数据，可以在链接时和其他可重定位目标文件合并创建一个可执行目标文件。</li>
<li><strong>可执行目标文件</strong>。可以直接被复制到内存上执行。</li>
<li><strong>共享目标文件</strong>。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态加载进内存并链接。</li>
</ul>
<p>目标文件按照一定的格式来组织。在 Windows 系统中为可移植可执行格式（Portable Executable，PE），Mac OS-X 使用 Mach-O 格式，现代 Linux 和 Unix 使用可执行可链接格式（Executable and Linkable Format，ELF）。</p>
<h2><span id="可重定位目标文件">可重定位目标文件</span></h2><p>多文件编译时，称一个<em>目标模块</em>为 <code>.o</code> 文件中的字节序列，<em>目标文件</em>为实际上磁盘中的文件。</p>
<p><strong>ELF 的格式</strong></p>
<ul>
<li><strong>ELF 头</strong> 现有 16 字节的序列描述生成文件的系统的字大小、字节顺序，后接 ELF 头大小、目标文件类型、机器类型、<em>节头部表</em>的文件偏移，节头部表中条目的大小和数量。</li>
<li><strong>节</strong> 夹在 ELF 头和节头部表之间的字节序列。其位置和大小由节头部表描述。典型的 ELF 文件包含下面的节<ul>
<li><code>.text</code> 机器代码。</li>
<li><code>.rodata</code> 只读数据，比如 <code>printf</code> 中的字符串常量和跳转表等。</li>
<li><code>.data</code> 已初始化的全局和静态变量。</li>
<li><code>.bss</code> 未初始化的全局和静态变量，以及初始化为 $0$ 的全局和静态变量。注意在可重定位目标文件中这一节只是占位符不占用空间，因为初始化为 $0$ 不需要额外信息。</li>
<li><code>.symtab</code> 符号表，存放定义和引用的函数和全局变量的信息。（不包含局部变量，仅声明的函数，.rodata）</li>
<li><code>.rel.text</code> 链接时可能需要修改的 <code>.text</code> 中的位置表。</li>
<li><code>.rel.data</code> 被模块引用或定义的所有全局变量的重定位信息。（已初始化的全局变量，其初值为外部全局变量或函数的地址，则可能会被修改）。</li>
<li><code>.debug</code> 调试符号表，包含局部变量和类型、全局变量、原始文件。（仅 <code>-g</code> 时生成）</li>
<li><code>.line</code> 原始程序行号和机器指令之间的映射。（仅 <code>-g</code> 时生成）</li>
<li><code>.strtab</code> 字符串表，包含 <code>.symtab</code>、<code>.debug</code> 中的符号表和节头部中的节名字。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>符号和符号表</strong> </p>
<p>每个可重定位目标模块 $m$ 都有一个符号表，包含 $m$ 中定义和引用的符号的信息。符号分为以下三种：</p>
<ul>
<li>由模块 $m$ 定义并能被其他模块引用的全局符号，称作全局链接器符号（非静态的函数和全局变量）。</li>
<li>由其他模块定义并被 $m$ 引用的全局符号，成为外部符号（其他模块中非静态的函数和全局变量）。</li>
<li>只被模块定义和引用的局部符号（带 <code>static</code> 属性的函数和全局变量）。<em>这些符号对其他模块不可见</em>。</li>
</ul>
<p>过程变量（即平常语境下的“局部变量”）在栈中，所以链接器不需要处理。函数中的 <code>static</code> 类过程变量不在栈中而是在 <code>.data</code> 或者 <code>.bss</code> 中，但是可以重名，这时编译器将向汇编器输出两个不同名字的局部链接器符号（比如 <code>x.1</code> 和 <code>x.2</code> 状物）。</p>
<p>符号表的格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> name;        <span class="comment">// 符号名字在字符串表中的偏移</span></span><br><span class="line">    <span class="type">char</span> type:<span class="number">4</span>,     <span class="comment">// 函数 / 类型</span></span><br><span class="line">         bingding:<span class="number">4</span>; <span class="comment">// 局部 / 全局</span></span><br><span class="line">    <span class="type">char</span> reserved;</span><br><span class="line">    <span class="type">short</span> section;   <span class="comment">// 到节头部表的索引</span></span><br><span class="line">    <span class="type">long</span> value;      <span class="comment">// 距离定义的目标的节的起始偏移（可重定位）或者绝对地址（可执行）</span></span><br><span class="line">    <span class="type">long</span> size;       <span class="comment">// 目标大小（byte）</span></span><br><span class="line">&#125; Elf64_Symbol;</span><br></pre></td></tr></table></figure>

<p><code>section</code> 可以是一些整数（<code>1</code> 表示 <code>.text</code>，<code>3</code> 表示 <code>.data</code>，etc.），也可以是一些特殊常数，称作<strong>伪节</strong>，伪节在节头部表中没有条目。</p>
<ul>
<li><code>ABS</code> 不该被重定位的符号。</li>
<li><code>UNDEF</code> 未定义的符号。</li>
<li><code>COMMON</code> 未被分配位置的未初始化数据目标。</li>
</ul>
<p><code>COMMON</code> 和 <code>.bss</code> 有一点区别，在 GCC 中一般未初始化的全局变量去 <code>COMMON</code>，未初始化的静态变量和初始化为 $0$ 的全局或静态变量去 <code>.bss</code>。但是这是一个很傻逼的历史遗留问题，可以用 <code>fno-common</code> 来让所有东西都去 <code>.bss</code>。在后面我们会看到为什么要留着一个 <code>COMMON</code>。</p>
<h2><span id="符号解析">符号解析</span></h2><blockquote>
<p>C++ 和 Java 发生重载的时候，编译器将类中每个重载函数的名字改成函数名 <code>__</code> 类名字符数加类名加参数表。比如 <code>Foo::bar(int, long)</code> 将会被改成 <code>bar__3Fooil</code>。</p>
<p>这个过程称作重整，反向过程称作恢复。</p>
</blockquote>
<p>定义<em>函数</em>和<em>已经初始化的全局变量</em>为强符号，<em>未初始化的全局符号</em>为弱符号。</p>
<p>当符号重名时，有如下规则：</p>
<ul>
<li>强符号不能重名。</li>
<li>一个强符号和多个弱符号重名，选择强符号。</li>
<li>有多个弱符号，则任选一个。</li>
</ul>
<p>如果遇到弱符号，编译器就会被放入 <code>COMMON</code> 伪节。但是如果多个模块里面发生了无意识的符号重名，就会寄的很惨，所以怀疑此类错误时一般打开 <code>fno-common</code>，这样如果定义了多个弱符号也会报错。</p>
<hr>
<p><strong>静态库</strong></p>
<p>为了引用标准函数，有几种极端的办法：</p>
<ul>
<li>让编译器生成标准函数代码。但这会显著增加编译器的复杂性。</li>
<li>每次链接都与定义了全体标准函数的模块（e.g. <code>libc.o</code>）链接。但这样很费内存。</li>
<li>为每个函数创建一个可重定位文件。但是这样你需要 <code>include</code> 大量的东西。</li>
</ul>
<p>解决的办法是把若干可重定位文件封装成一个静态库文件（<code>.a</code>，存档文件，一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置）。</p>
<p>通过 AR 工具来创建一个静态库。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="literal">-c</span> addvec.c mulvec.c</span><br><span class="line">ar rcs libvector.a addvec.o mulvec.o</span><br></pre></td></tr></table></figure>

<p>用</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="literal">-static</span> <span class="literal">-o</span> prog main.o ./libvector.a</span><br></pre></td></tr></table></figure>

<p>或者等价地</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="literal">-static</span> <span class="literal">-o</span> prog main.o <span class="literal">-lvector</span></span><br></pre></td></tr></table></figure>

<p>来进行链接。<code>-static</code> 参数指示构建一个完全链接的可执行目标文件。</p>
<hr>
<p><strong>链接器解析引用流程</strong></p>
<p>从左到右扫描出现在命令行上的目标文件和存档文件，维护三个集合：可重定位目标文件集合 $E$，未解析符号集合 $U$，已定义符号集合 $D$。</p>
<ul>
<li>如果是目标文件那么其会被加入 $E$，然后根据内容修改 $U, D$。</li>
<li>如果是存档文件，那么链接器将尝试匹配 $U$ 和存档文件成员中的定义。如果对上了，就将该成员加入 $E$，然后修改 $U, D$，重复直到 $U, D$ 都不再变化。</li>
</ul>
<p>如果 $U$ 非空则发生链接错误，否则继续进行重定位之类的工作。</p>
<p>从上述过程中看出静态库应该被放在命令的最后。且如果有相互依赖关系，需要在命令行中重复库或者合并相互依赖的库。</p>
<details class="note "><summary><p>Example.</p>
</summary>
<p><code>libx.a</code> 依赖 <code>liby.a</code> 中的目标文件，而 <code>liby.a</code> 也依赖 <code>libx.a</code> 中的目标文件。那么此时命令应当是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc foo.c libx.a liby.a libx.a</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="重定位">重定位</span></h2><p>过程大致分成两段：</p>
<ul>
<li><strong>重定位节和符号定义</strong> 合并所有相同类型的节，给每条指令和全局变量分配唯一的运行时内存。这部分比较 trivial。</li>
<li><strong>重定位节中的符号引用</strong> 修改符号引用，使其指向正确的地址。</li>
</ul>
<hr>
<p><strong>重定位条目</strong></p>
<p>回忆之前讲的 <code>rel.text</code> 和 <code>rel.data</code> 两节，当汇编器遇到一个最终位置未知的符号引用就往里面塞一个<em>重定位条目</em>。一个重定位条目结构为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> offset;    <span class="comment">// 该需重定位的引用在节中的偏移</span></span><br><span class="line">    <span class="type">long</span> type:<span class="number">32</span>,   <span class="comment">// 重定位类型（下文有写）</span></span><br><span class="line">         symbol:<span class="number">32</span>; <span class="comment">// 符号表下标（应该指向哪个符号）</span></span><br><span class="line">    <span class="type">long</span> addend;    <span class="comment">// 有符号常数，一些类型的重定位需要用它来对地址做偏移修改（下一段有写）</span></span><br><span class="line">&#125; Elf_Rela;</span><br></pre></td></tr></table></figure>

<p>重定位类型有 $32$ 中，我们只关心两种基本的类型：</p>
<ul>
<li><code>R_X86_64_PC32</code> 重定位一个 $32$ 位 PC 相对地址的引用。</li>
<li><code>R_X86_64_32</code> 重定位一个 $32$ 位绝对地址的引用。</li>
</ul>
<p>这两种重定位模型假设代码和数据加起来不超过 $2$ GB，因此都可以用 $32$ 位相对地址表示。</p>
<hr>
<p><strong>重定位符号引用</strong></p>
<p>假设现在已经做完了重定位节和符号定义。那么重定位算法大概是：</p>
<ul>
<li>对于节 $s$（$s &#x3D; \texttt{.data} &#x2F; \texttt{.text}$），设其地址为 <code>ADDR(s)</code>。</li>
<li>考察节 $s$ 的重定位条目表中的每一项 $r$。<ul>
<li>找到对应的位置 <code>refptr = s + r.offset</code>。</li>
<li>若为 PC 相对寻址 <code>r.type == R_X86_64_PC32</code>，找到该位置的运行时地址 <code>ADDR(s) + r.offset</code>，然后修改目标位置 <code>*refptr = (unsigned)(ADDR(r.symbol) + r.addend - refaddr)</code></li>
<li>若为绝对寻址 <code>r.type == R_X86_64_32</code>，则直接改 <code>*refptr = (unsigned)(ADDR(r.symbol) + r.addend)</code>。</li>
</ul>
</li>
</ul>
<p>回忆相对寻址时用的是<strong>下一条指令开始的地址</strong>，所以在 <code>R_X86_64_PC32</code> 时，<code>addend</code> 是重定位目标位置的开始地址减去下一条指令的开始地址。</p>
<blockquote>
<p>一定记住 x86_64 是小端法，所以你看到重定位完符号引用之后的数字是倒过来的。</p>
</blockquote>
<h2><span id="可执行目标文件">可执行目标文件</span></h2><p>可执行目标文件对比可重定位目标文件的差距是：</p>
<ul>
<li><strong>ELF 头</strong> 还需要包括程序的<em>入口点</em>。</li>
<li><strong>段头部表</strong> 描述段的信息。描述一个段需要<ul>
<li><code>off</code> 目标文件中的偏移。</li>
<li><code>vaddr / paddr</code> 内存地址。</li>
<li><code>align</code> 对齐要求。对于任意的段，链接器必须使得其起始地址（段中第一个节的起始地址）满足 <code>vaddr % align = off % align</code>。</li>
<li><code>filesz</code> 目标文件中的段大小。</li>
<li><code>memsz</code> 内存中的段大小。<code>memsz</code> 和 <code>filesz</code> 不总是一样的。回忆 <code>.bss</code> 区不占空间，于是 <code>.data</code> 的 <code>memsz</code> 比 <code>filesz</code> 多出来的部分将会被用来开 <code>.bss</code> 节。</li>
<li><code>flags</code> 访问权限，可以是 <code>r-x</code>、<code>rw-</code> 之类的。</li>
</ul>
</li>
<li><strong><code>.init</code> 节</strong> 定义了一个 <code>_init</code> 函数，程序的初始化代码会调用它。</li>
<li><strong>没有 <code>.rel</code> 节</strong> 因为已经重定位完了。</li>
</ul>
<blockquote>
<p><code>align</code> 的必要性在后面虚拟内存一节才被揭示。</p>
</blockquote>
<p>ELF 头，段头部表，<code>.init</code>，<code>.text</code>，<code>.rodata</code> 是只读内存段；<code>.data</code>，<code>.bss</code> 是读写内存段；<code>.symtab</code>，<code>.debug</code>，<code>.line</code>，<code>.strtab</code>，节头部表之类的属于不加载到内存的符号表和调试信息。</p>
<p>可执行文件运行时被加载器（loader）按照段头部表的指示。复制到内存中去执行。只读代码段从 <code>0x400000</code> 开始向上增长，接下来是读&#x2F;写段、向上增长的堆、共享库内存、向下增长的栈（从 $2^{48} - 1$ 开始向下增长）、对用户不可见的内核代码。运行时首先执行 <code>_start</code> 函数，<code>_start</code> 调用 <code>__libc_start_main</code>，此函数初始化执行环境然后调用用户层的 <code>main</code> 函数，处理 <code>main</code> 的返回值并在需要的时候把控制返回给内核。</p>
<h2><span id="动态链接">动态链接</span></h2><p>动态链接有两方面动机：</p>
<ul>
<li>让程序能够 follow 标准库的更新，不需要重新链接。</li>
<li>减少高频率使用的库（<code>printf</code>，<code>scanf</code> 等）的内存占用。</li>
</ul>
<p>用如下办法创建一个动态链接库</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="literal">-shared</span> <span class="literal">-fpic</span> <span class="literal">-o</span> libvector.so addvec.c multvec.c</span><br></pre></td></tr></table></figure>

<p>其中 <code>-fpic</code> 指示生成位置无关代码。（在下一小节解释）</p>
<p>链接除了可以手动编译：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="literal">-o</span> prog main.c ./libvector.so</span><br></pre></td></tr></table></figure>

<p>之外还可以使用一些神秘函数，编译的使用要加 <code>-rdynamic</code> 选项，<code>-ldl</code> 应该是链接上动态链接器的代码</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="literal">-rdynamic</span> <span class="literal">-o</span> prog main.c <span class="literal">-ldl</span></span><br></pre></td></tr></table></figure>

<p>函数有下面三个，直接看肯定看不懂在干什么，推荐先看后面的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure>

<p>如果成功则返回一个 handle。</p>
<p>可以在运行时加载和链接共享库 <code>filename</code>。<code>flag</code> 可以是</p>
<ul>
<li><code>RTLD_NOW</code> 立即解析外部符号引用。</li>
<li><code>RTLD_LAZY</code> 等到执行库中代码时再解析。</li>
<li><code>RTLD_GLOBAL</code> 前面两个参数可以或上这东西。</li>
</ul>
<p>将用已经用 <code>RTLD_GLOBAL</code> 打开的库解析 <code>filename</code> 中的外部符号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">char</span> *symbol)</span>; </span><br></pre></td></tr></table></figure>

<p>查询一个共享库里面是否有 <code>symbol</code>。成功返回符号地址，否则返回 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">void</span> *handle)</span>; </span><br></pre></td></tr></table></figure>

<p>如果没有其他共享库还在使用这个共享库，就将其关闭。成功返回 $0$，否则返回 $1$。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>返回前面几个函数调用最近发生的错误。没出错返回 NULL。</p>
<p>使用方法为（在上面编译的 <code>main.c</code> 中写主函数）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *handle;</span><br><span class="line">    <span class="type">void</span> (*addvec)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libvector.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span>(!handle) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addvec = dlsym(handle, <span class="string">&quot;addvec&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在链接好了，你可以使用 addvec 函数了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>位置无关代码</strong></p>
<p>显然为了保持动态库的特性，一个动态库必须被能够被复制到共享库内存中的任何位置都能正常运行。这需要将代码编译成<strong>位置无关代码</strong>（可以加载但是无需重定位）。那么对库内部的引用可以简单地解决（使用 PC 相对寻址），但是外面的模块调用库函数则需要解决两方面问题：</p>
<ol>
<li><p><strong>PIC 数据引用</strong></p>
<p>注意代码段和数据段之间的距离总是一个常量，那么可以在 <code>.data</code> 区的最前面定义一个全局偏移量表 GOT，每个全局数据目标都会在 GOT 里面有一个八字节条目，和一个重定位记录。动态链接时链接器会让 GOT 里面的条目指向正确的地址。在引用一个外部符号时，先拿着 PC 找到对应的 GOT 表项，然后找到正确的位置。你可能会编译出这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov 0x2008b9(%rip), %rax  # 拿着 PC 找到 GOT 表项</span><br><span class="line">addl $0x1, (%rax)         # 拿着 GOT 表项找到正确的引用地址</span><br></pre></td></tr></table></figure></li>
<li><p><strong>PIC 函数调用</strong></p>
<p>显然库里面的函数只会用很少一部分，所以正常的想法是做某种 lazy load。</p>
<p>这里需要用到两个数据结构，GOT 和 PLT。回忆 GOT 是一个每个 entry 为 8 字节整数的数组。而 PLT 是一个每个 entry 32 字节代码的数组。</p>
<ul>
<li><p><strong>GOT 数组</strong></p>
<p><code>GOT[0]</code> 存的是 <code>.dynamic</code> 节开始的位置，不知道是干什么的。</p>
<p><code>GOT[1]</code> 存的是重定位条目的地址。（给动态链接器的参数）</p>
<p><code>GOT[2]</code> 存的是动态链接器的地址。</p>
<p>其余项一开始都指向对应的 PLT 表项的<strong>第二行</strong>，在被调用第一次之后会被链接器改成实际上的引用地址。</p>
</li>
<li><p><strong>PLT 数组</strong></p>
<p><code>PLT[0]</code> 是下面两行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq *GOT[1]</span><br><span class="line">jmpq *GOT[2]   # 运行动态链接器，它会拿着栈里面的参数去做重定位</span><br></pre></td></tr></table></figure>

<p><code>PLT[1]</code> 是一个调用 <code>__libc_start_main</code>，这里我们不关心。</p>
<p><code>PLT[2]</code> 开始，都是描述一个外部引用的，下面三行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmpq *GOT[4]  # 第一次调用这玩意会直接传到下一行，下一次就会传到正确的引用位置</span><br><span class="line">pushq $0x1    # 把这个外部引用的 id 推到栈里</span><br><span class="line">jmpq 4005a0   # 4005a0 是 PLT[1] 的第一行代码，现在动态链接器会拿着正确的参</span><br><span class="line">              # 数去找这个外部引用的实际位置，完成重定位</span><br></pre></td></tr></table></figure>

<p>目标模块里面的函数调用就被编译成 <code>call</code> 对应的 PLT 的第一行。</p>
</li>
</ul>
</li>
</ol>
<h1><span id="异常控制流">异常控制流</span></h1><h2><span id="异常">异常</span></h2><p>在执行某指令 $I_{\rm curr}$ 时，处理器检测到发生一个<em>事件</em>，就会拿着事件的编码在一个称作<em>异常表</em>（这个表的地址可以在 CPU 中的异常表基址寄存器里找到）的结构中找到处理此事件的<em>异常处理程序</em>的代码，执行完毕后选择：</p>
<ul>
<li>重新执行 $I_{\rm curr}$。</li>
<li>执行下一条指令 $I_{\rm next}$。</li>
<li>终止该程序。</li>
</ul>
<p>这样发生的控制流的突变，称作<strong>异常</strong>。</p>
<p>回忆控制流中发生的跳转还有一种形式是<em>函数调用</em>，但是异常和函数调用有如下区别：</p>
<ul>
<li>不一定返回到下一条指令。</li>
<li>可能在栈中压入包含当前条件码的 <code>EFLAGS</code> 寄存器和其他内容压栈。</li>
<li>所有东西都会被压到内核栈上。</li>
<li>异常处理程序运行在<em>内核模式</em>下。</li>
</ul>
<hr>
<p>异常可以分为</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">原因</th>
<th align="left">同步 &#x2F; 异步</th>
<th align="left">返回行为</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">中断</td>
<td align="left">I&#x2F;O 设备的信号</td>
<td align="left">异步</td>
<td align="left">总是返回到下一条指令</td>
<td align="left">定时器展示信号、I&#x2F;O 完成</td>
</tr>
<tr>
<td align="left">陷阱</td>
<td align="left">有意的异常</td>
<td align="left">同步</td>
<td align="left">总是返回到下一条指令</td>
<td align="left">系统调用</td>
</tr>
<tr>
<td align="left">故障</td>
<td align="left">潜在可恢复的错误</td>
<td align="left">同步</td>
<td align="left">可能返回到当前指令，也可能不返回</td>
<td align="left">缺页</td>
</tr>
<tr>
<td align="left">终止</td>
<td align="left">不可恢复的错误</td>
<td align="left">同步</td>
<td align="left">从不返回</td>
<td align="left">除 $0$，一般保护故障</td>
</tr>
</tbody></table>
<p>系统调用包括 <code>read</code>，<code>write</code> 等 I&#x2F;O 函数，以及 <code>mmap</code>，<code>getpid</code>，<code>fork</code>，<code>execve</code>，<code>kill</code> 之类的常见的操作。每种系统调用有一个编号，通过在 <code>%rax</code> 中保存该编号，然后用 <code>rdi, rsi, rdx, r10, r8, r9</code> 来传递至多 $6$ 个参数，然后通过汇编指令 <code>syscall</code> 来产生一个陷阱。</p>
<p>一般保护故障包括引用未定义的虚拟内存区域，试图写只读文本段等。</p>
<h2><span id="进程">进程</span></h2><p>一个进程享有一个独立的虚拟地址空间。不同的进程可以<strong>并发</strong>地执行。</p>
<hr>
<p><strong>用户模式和内核模式</strong></p>
<p>摆了。</p>
<h1><span id="系统级-ix2fo">系统级 I&#x2F;O</span></h1><p>Linux 的哲学是<strong>一切皆文件</strong>。系统的所有组成部分，包括目录、设备、网络通信等都用文件来刻画。</p>
<p>每一个被程序打开的文件对应一个<strong>描述符</strong>。初始时打开了三个文件：</p>
<ol start="0">
<li><strong>STDIN</strong>。</li>
<li><strong>STDOUT</strong>。</li>
<li><strong>STDERR</strong>。</li>
</ol>
<p>我们讲的顺序可能和原书不一样。</p>
<hr>
<p><strong>文件元数据</strong></p>
<p>通过如下函数来读取关于文件的信息（称作文件的元数据）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>stat</code> 结构描述了文件的 <code>inode</code>（唯一标识符，在下面的实验中可以深刻理解到这一点），大小，所有用户，所有用户所在组，创建和修改时间，文件类型和权限（<code>st_mode</code>），还有一些其他的神秘东西。</p>
<p>用下面的 <code>sys/stat.h</code> 中的宏来从 <code>st_mode</code> 里面读取文件类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S_ISREG(m)   // 这是一个普通文件吗？</span><br><span class="line">S_ISDIR(m)   // 这是一个目录文件吗？</span><br><span class="line">S_ISSOCK(m)  // 这是一个套接字文件吗？</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>目录也是文件</strong></p>
<p>通过下面的一系列函数可以查询目录信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;    <span class="comment">// 给出目录名，返回一个目录流。</span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>; <span class="comment">// 从目录流里面读出一项。如果这个流读完了或者出错，返回 NULL</span></span><br><span class="line">                                   <span class="comment">// （错误信息存在 errno 里面）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;           <span class="comment">// 关闭流并释放资源</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>dirent</code> 是这样的一个结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  <span class="type">ino_t</span> d_ino;       <span class="comment">// inode</span></span><br><span class="line">  <span class="type">char</span>  d_name[<span class="number">256</span>]; <span class="comment">// 文件名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details class="note "><summary><p><strong>小实验</strong></p>
</summary>
<p>用下面的代码来获取某个目录下的所有文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *streamp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dep</span>;</span></span><br><span class="line"></span><br><span class="line">    streamp = opendir(<span class="string">&quot;./attacklab&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((dep = readdir(streamp)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found file (%ld): %s\n&quot;</span>, dep-&gt;d_ino, dep-&gt;d_name);</span><br><span class="line">    </span><br><span class="line">    closedir(streamp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的可以发现在 <code>.</code> 下面查到的 <code>.</code> 的 <code>inode</code> 和在 <code>./attacklab</code>（<code>./</code> 下面的一个目录）下面查到的 <code>..</code> 具有相同的 <code>inode</code>。</p>

</details>

<hr>
<p><strong>开关文件</strong></p>
<p><code>open</code> 函数将 <code>filename</code> 转换为文件描述符，并返回该数字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span> *filename, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>flags</code> 是指明访问方式的参数，可以是如下几个东西的或：</p>
<ul>
<li><code>O_RDONLY</code>：只读。</li>
<li><code>O_WRONLY</code>：只写。</li>
<li><code>O_RDWR</code>：可读可写。</li>
<li><code>O_CREAT</code>：如果不存在就创建一个空文件。</li>
<li><code>O_TRUNC</code>：如果文件已经存在，就将其截断（理解成清空？）。</li>
<li><code>O_APPEND</code>：每次写之前，将文件位置（可以理解为“光标”）移动到文件结尾。</li>
</ul>
<p><code>mode</code> 指明新文件权限，可以是几个掩码的或，每个掩码的结构是前缀接上后缀：其中前缀有 <code>S_IR</code>，<code>S_IW</code>，<code>S_IX</code> 指示读、写、运行权限；后缀包括 <code>USR</code>，<code>GRP</code>，<code>OTH</code>，指示拥有者、拥有者所在组、任何人拥有的权限。</p>
<p>通过 <code>close</code> 关闭一个一打开的描述符。（注意你关闭的是描述符，在<em>已打开文件的组织</em>小节你就会意识到这里的区别）</p>
<hr>
<p><strong>读写文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>; </span><br></pre></td></tr></table></figure>

<p><code>read</code> 从描述符 <code>fd</code> 对应的文件里读至多 $n$ 个字节到 <code>buf</code> 里。<code>write</code> 从 <code>buf</code> 开始复制至多 $n$ 个字节到 <code>fd</code> 对应的文件里。返回值为实际上传送的字节数。</p>
<p>注意到遇到下面三种情况，返回值会小于 $n$，此时返回的值称作<em>不足值</em>：</p>
<ul>
<li>读到 <code>EOF</code>。</li>
<li>从终端读文件，一行没有 $n$ 这么长。</li>
<li>从套接字里读写，发生网络延迟。</li>
</ul>
<p>据说可以用 <code>lseek</code> 函数来显式修改当前文件的位置，但书上没写怎么用的，摆了。</p>
<hr>
<p><strong>Robust I&#x2F;O</strong></p>
<p>自动处理不足值，在对应的描述符里面使劲读写直到读够了或者 EOF。</p>
<p>具体有哪几个函数哥们摆了😄。</p>
<p>关于输入输出函数的选择，有如下经验：</p>
<ul>
<li>尽可能用标准输入输出 <code>scanf</code> &#x2F; <code>printf</code>。</li>
<li>不要用 <code>scanf</code> &#x2F; <code>rio_readlineb</code> 之类的和 <code>\n</code> 相关的函数来读入二进制文件。</li>
<li>对网络套接字用 <code>rio</code> 函数。</li>
</ul>
<hr>
<p><strong>已打开文件的组织</strong></p>
<p>描述符表指文件表，文件表指 v-node 表。</p>
<p><img src="/../picture/FileKernelDS.jpg"></p>
<ul>
<li><em>描述符表</em>。每个进程有独立的描述符表。表项指向文件表。</li>
<li><em>文件表</em>。所有进程共享，每个表项是一个结构，结构中包含：<ul>
<li>一个指向 v-node 表的指针。</li>
<li>文件位置（“光标”，部分网上资料也管这东西叫做文件偏移量），这个值将在读写文件之后发生变化。</li>
<li><code>refcnt</code> 引用计数。<strong>注意这是文件表表项的引用计数，而非对应文件的引用计数。</strong></li>
</ul>
</li>
<li><em>v-node 表</em> 包含 <code>stat</code> 里面的大部分信息。</li>
</ul>
<p>当一个文件表表项的 <code>refcnt</code> 为 $0$ 时，其将会被关闭。需要区分下面两种情况：</p>
<ul>
<li><strong>重复打开同名文件</strong>：这时候是有两个不同的、<code>refcnt</code> 都是 $1$ 的文件表，指向同一个 v-node 表项。</li>
<li><strong>发生 <code>fork</code> 创建子进程</strong>：子进程会继承父进程的描述符表，但本质是不同的。此时相关文件表的 <code>refcnt</code> 将加一。</li>
</ul>
<hr>
<p><strong>I&#x2F;O 重定向</strong></p>
<p>在阐释了文件打开的结构之后，I&#x2F;O 重定向的原理和办法就很显然了：直接改描述符表，骗程序自己在读写原来的文件。</p>
<p><code>dup2(oldfd, newfd)</code> 将 <code>oldfd</code> 的描述符表表项改成 <code>newfd</code> 的描述符表表项。这样会让 <code>newfd</code> 指向的文件表表项的 <code>refcnt</code> 加一，<code>oldfd</code> 指向的文件表表项的 <code>refcnt</code> 减一。</p>
<p>你可能还会希望重定向回去，这就需要备份原来的描述符表。但是描述符表是内核数据结构。这时候的办法是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd_save = dup(fd); <span class="comment">// 这样保存原来的描述符表表项</span></span><br><span class="line"><span class="comment">// 在这里重定向，然后做一些操作</span></span><br><span class="line">dup2(fd, fd_save);     <span class="comment">// 这样重定向回去 </span></span><br></pre></td></tr></table></figure>

<h1><span id="并发编程">并发编程</span></h1><h2><span id="基于进程的并发编程">基于进程的并发编程</span></h2><p>每次 <code>accept</code> 完就 <code>fork</code> 一个子进程。注意父进程需要关闭已连接的描述符 <code>connfd</code>，子进程需要关闭监听套接字 <code>listenfd</code>，结束后要关闭 <code>connfd</code>，否则会一直占用系统资源。</p>
<p>需要一个 <code>SIGCHLD</code> 的处理程序（<code>while(waitpid(-1, 0, WNOHANG));</code> 状物）。</p>
<blockquote>
<p><strong>Remark.</strong> 这里父进程关闭 <code>confd</code> 之后，对 <code>connfd</code> 的文件表影响只是 <code>refcnt</code> 减一，子进程仍然可以用 <code>confd</code> 读写。</p>
<p>子进程也可以不关闭 <code>connfd</code>，因为进程因为某种原因终止时，内核会自动关闭它打开的文件。</p>
</blockquote>
<p>进程之间有独立的地址空间，可以避免很多并发错误，但是为了共享信息必须使用显式 IPC 机制，而且上下文切换非常慢。</p>
<h2><span id="基于-ix2fo-多路复用的并发编程">基于 I&#x2F;O 多路复用的并发编程</span></h2><p><strong><code>select</code> 函数</strong></p>
<p>主要依赖 <code>select</code> 函数及其配套操作。<code>select</code> 函数非常复杂，我们将后面三个参数都设置为 <code>NULL</code> 来使用其功能之一：挂起进程，知道一组描述符准备好读。</p>
<p>首先引入类型 <code>fd_set</code> 类型抽象了一个描述符的集合，提供了若干个访问此集合的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD_ZERO(fd_set *fd_et);          <span class="comment">// 清空集合</span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset);   <span class="comment">// 从 `fd_set` 中删除元素 `fd`</span></span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset);   <span class="comment">// 向 `fd_set` 中插入元素 `fd`</span></span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set *fdset); <span class="comment">// 查询 `fd` 是否属于 `fd_set`</span></span><br></pre></td></tr></table></figure>

<p>接下来介绍 <code>select</code> 函数的原型（<code>n</code> 是 <code>fdset</code> 的最大值加一）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> n, fd_set* fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>本函数将挂起当前进程，直到 <code>fdset</code> 中的某些描述符准备好读了。此函数返回已准备好的描述符个数（非零），若出错返回 $-1$，同时有个副作用是将 <code>fdset</code> 重置为准备好读的子集。</p>
<p>现在如果你将 <code>STDIN_FILNO</code> 和 <code>listen_fd</code> 添加到 <code>fdset</code> 当中，然后 <code>select(listen_fd + 1, fdset)</code>，就可以同时接受来自标准输入和连接的读入，从而实现了等效意义上的并发。</p>
<hr>
<p><strong>并发事件驱动服务器</strong></p>
<p>你可能希望事件的粒度更细，比如说从一个 <code>connfd</code> 中读入一行就响应一次乃至读入一个字符就响应一次之类的。</p>
<p>这时容易想象的办法是手动把处理事件的逻辑流建模成一个状态机（回忆一个状态机就是一个带副作用的 DFA）。比如如果只是读一行，那么状态机上只有一个状态，代表“等待描述符 <code>connfd</code> 准备好读”，转移只有一个自环，这个自环是事件“<code>connfd</code> 准备好读了”，副作用是从 <code>connfd</code> 中读一行并且做一些操作。</p>
<p>代码非常唐而且长，摆了。</p>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>将所有东西集中在一个代码中，所以你对各个连接的控制能力非常强，可以提供针对性的服务。</li>
<li>逻辑流之间的通信很容易。</li>
<li>单进程程序方便调试。</li>
<li>没有上下文切换的时间开销。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>编码复杂。你需要把一段代码手动搓成状态机。</li>
<li>一攻击整个服务器直接寄完。</li>
</ul>
<h2><span id="基于线程的并发编程">基于线程的并发编程</span></h2><p>线程系指运行在进程上下文中的逻辑流。一个进程中的所有线程共享该进程的整个虚拟地址空间、具有相同的地位（主线程和对等线程的区别只是它是第一个运行的线程）</p>
<hr>
<p><strong>共享内存模型</strong></p>
<p>书的顺序有点令人迷惑，我们先讲理论，然后在讲一些函数。</p>
<p>每个线程拥有自己独立的线程上下文，包括线程 ID、栈、栈指针、程序计数器、条件码、通用目的寄存器值。每个线程和其他线程共享进程上下文的其他部分。</p>
<p>这里说的独立栈可能让人难以理解，我们做了一些测试，发现它实际上就是在虚拟地址空间中的栈区域里给每个线程分配了一段小栈：</p>
<details class="note "><summary><p><strong>测试内容</strong></p>
</summary>
<p>运行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(func)(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span> &#123;</span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack of thread %lx: %lx\n&quot;</span>, pthread_self(), (<span class="type">long</span>)&amp;temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread: %lx\n&quot;</span>, (<span class="type">long</span>)&amp;now);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">pthread_t</span> *tid;</span><br><span class="line">        pthread_create(tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Main thread: 7fff2b60a578</span><br><span class="line">Stack of thread 710cc06006c0: 710cc05ffea4</span><br><span class="line">Stack of thread 710cc06006c0: 710cc05ffea4</span><br><span class="line">Stack of thread 710cbe8006c0: 710cbe7ffea4</span><br><span class="line">Stack of thread 710cbd4006c0: 710cbd3ffea4</span><br><span class="line">Stack of thread 710cbfc006c0: 710cbfbffea4</span><br><span class="line">Stack of thread 710cbc0006c0: 710cbbfffea4</span><br><span class="line">Stack of thread 710cbf2006c0: 710cbf1ffea4</span><br><span class="line">Stack of thread 710cbca006c0: 710cbc9ffea4</span><br><span class="line">Stack of thread 710cbde006c0: 710cbddffea4</span><br><span class="line">Stack of thread 710cc06006c0: 710cc05ffea4 </span><br></pre></td></tr></table></figure>
</details>

<p>这个小栈是<strong>不对其他线程设防</strong>的。</p>
<p>基于以上线程上下文的模型，我们可以知道在多线程编程时：</p>
<ul>
<li><strong>全局变量</strong> 在虚拟内存中只有一份，是共享的。</li>
<li><strong>本地静态变量</strong> 在虚拟内存中只有一份，是共享的。</li>
<li><strong>局部变量</strong> 在每个线程的栈上都有一份，基本上是私有的。（说基本上是因为栈不设防）</li>
</ul>
<hr>
<p><strong>Posix 线程</strong></p>
<p>关于线程的一套接口。方便起见我们定义如下线程例程的类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(func)(<span class="type">void</span> *); <span class="comment">// 将 func 定义为 void* -&gt; void* 的函数</span></span><br></pre></td></tr></table></figure>

<p>函数的参数和返回值都是通用指针，应该是用来实现多态的。</p>
<p>通过 <code>pthread_create</code> 来创建线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">pthread_attr_t</span> *attr, func *f, <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<p>此函数创建一个新线程，在新线程中运行函数（称作线程例程） <code>f</code>（向 <code>f</code> 传入参数 <code>*arg</code>）。<code>attr</code> 是一些关于新线程默认属性的参数，这里不讲。新线程的 <code>id</code> 通过被存到 <code>*tid</code> 里面来告知主线程。</p>
<p>通过 <code>pthread_self</code> 来获得自己的线程 ID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>线程终止可能是如下几种情况：</p>
<ul>
<li><p>线程例程返回。</p>
</li>
<li><p>调用 <code>pthread_exit</code> 显示终止线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *thread_return)</span>; </span><br></pre></td></tr></table></figure>

<p>参数是线程的返回值。主线程调用此函数后会等待其他对等线程终止，然后主线程和整个进程才终止。</p>
</li>
<li><p>对等线程调用 <code>exit()</code>，那么整个进程全部终止。</p>
</li>
<li><p>调用 <code>pthread_cancel()</code> 来杀掉对等线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span>; </span><br></pre></td></tr></table></figure></li>
</ul>
<p>通过 <code>pthread_join</code> 来等待其他线程终止，获取其返回值（注意和 wait 不一样，你只能指定等待某一个线程终止），并回收其资源：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span>; </span><br></pre></td></tr></table></figure>

<p>通过 <code>pthread_detach</code> 来分离线程。线程是可结合的或者分离的。一个可结合的线程在被其他线程回收之前，其资源（如栈）都是不释放的。一个分离的线程不能被其他线程回收或者杀死，其终止时系统自动回收资源。默认情况下线程都是可结合的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br></pre></td></tr></table></figure>

<p>通过 <code>pthread_once</code> 来做初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>

<p><code>once_control</code> 是一个指示初始化函数分类的标记：<code>pthread_once</code> 函数的作用是在第一次以 <code>once_control</code> 为参数调用的时候，其调用 <code>init_routine</code>，此后再一次以 <code>once_control</code> 为参数调用，它不做任何事情。</p>
<p>可以想象这玩意是用来在多线程编程时初始化一些共享全局变量的。</p>
<hr>
<p><strong>基于线程的并发服务器</strong></p>
<p>每次 <code>accept</code> 到一个连接，就 <code>pthread_create</code> 一个对等线程。现在核心的问题是怎么把 <code>connfd</code> 传递给对等线程。</p>
<p>直觉上办法是直接用 <code>&amp;connfd</code> 传。但回忆主线程和对等线程运行的顺序是不确定，所以如果对等线程做 <code>int connfd = *((int *)vargp)</code> 之前，主线程又收到了一个连接然后改变了 <code>connfd</code> 就倒闭了。</p>
<p>正确的办法是主线程 <code>malloc</code> 一个空间，然后把 <code>connfd</code> 存进去。对等线程拿到 <code>connfd</code> 之后 <code>free</code> 掉这个空间（<code>vargp</code>）来防止内存泄漏。</p>
<h2><span id="线程同步和资源调度">线程同步和资源调度</span></h2><p>因为线程中存在一些共享变量，所以会有一些阴间问题。</p>
<p><strong>竞争</strong></p>
<p>一个例子是，假设 <code>cnt</code> 是一个全局变量，那么在做 <code>cnt++</code> 时，其实汇编是有三个阶段的：从加载，运算，写回。如果两个线程的执行顺序为：</p>
<ol>
<li>线程 1 访存，线程 2 访存。</li>
<li>线程 1 运算，线程 2 运算，线程 1 写回，线程 2 写回。</li>
</ol>
<p>那么实际上 <code>cnt</code> 只被加了一次。直观地，可以画出如下的进度图（在这个局部意义下，一个线程分为 $H$ 头、$L$ 加载，$U$ 运算，$S$ 写回，$T$ 尾五部分，图上的坐标点 $(x, y)$ 表示线程 1 在 $x$ 阶段，线程 2 在 $y$ 阶段）</p>
<p><img src="/../picture/TrajectoryGraph.png"></p>
<p>这样的不安全是操作非原子导致的。可以通过信号量来规避这种情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="number">0</span>, <span class="type">unsigned</span> <span class="type">int</span> value)</span>; <span class="comment">// 将信号量 sem 初始化为 value</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *s)</span>;                          <span class="comment">// P(s)，称作加锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *s)</span>;                          <span class="comment">// V(s)，称作释放</span></span><br></pre></td></tr></table></figure>

<p>$P(s)$ 和 $V(s)$ 是 Dijkstra 提出的两种抽象的原子操作。</p>
<ul>
<li>$P(s)$：如果 $s$ 非零，那么将 $s$ 减一，并立即返回。否则，挂起该线程，直到 $s$ 变成非零。在重启时才执行前面的操作。</li>
<li>$V(s)$：将 $s$ 加一，并重启某一个阻塞在 $P(s)$ 上的线程。</li>
</ul>
<p>所以如果你在 <code>cnt++</code> 前面 $P$ 一下，后面 $V$ 一下，就不可能出现上面的情况。几何上相当于用一个禁止区完全包住了不安全区。</p>
<p>另一个例子是上一节讲的传入 <code>connfd</code> 的例子。</p>
<hr>
<p><strong>死锁</strong></p>
<p>可以想象如果你有两组锁，两个线程分别是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread 1</span></span><br><span class="line">P(s)</span><br><span class="line">P(t)</span><br><span class="line">V(s)</span><br><span class="line">V(t)</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 2</span></span><br><span class="line">P(t)</span><br><span class="line">P(s)</span><br><span class="line">V(s)</span><br><span class="line">V(t)</span><br></pre></td></tr></table></figure>

<p>如果运行顺序让线程 $1$ 先持有 $s$，线程 $2$ 持有 $t$，那么他们就会卡在第二行，出现<strong>死锁</strong>。直观地：</p>
<p><img src="/../picture/Deadlock.png"></p>
<p>但是有如下结论：</p>
<div class="note info"><p><strong>定理.</strong> 如果为所有信号量指定一个全序，所有线程均按照该全序从小到大加锁，并按照相反的顺序释放，那么一定不会有死锁。</p>
<details class="note "><summary><p><em>证明.</em></p>
</summary>
<p>假设有 $n$ 个信号量，考虑在线程 $i$ 做 $P(s_i)$ 的时候出现了死锁。定义集合 $S &#x3D; \{s_1, …, s_n\}$，$S$ 是有限全序集的子集，其中有极大元。</p>
<p>但是根据死锁的定义，对于任意 $s_i$，都存在一个 $j$ 使得线程 $j$ 中 $P$ 了 $s_i$。因为我们按照全序从小到大加锁，所以 $s_j &gt; s_i$。$s_i$ 都不是极大元。这导出了矛盾。$\square$</p>

</details></div>

<hr>
<p><strong>线程安全</strong></p>
<p>主要有以下四类线程不安全的函数：</p>
<ol>
<li><strong>不保护共享变量</strong>。<em>修改方法是加锁。</em></li>
<li><strong>保持跨越多个调用的状态的函数</strong>。比如 <code>rand()</code>，你可能希望指定 <code>seed</code> 之后每个线程都生成一样的序列，但是 <code>seed</code> 是一个静态变量，就不能达到这个效果。修改方法是<em>重写</em>。</li>
<li><strong>返回指向静态变量得到指针的函数</strong>。这样会导致竞争。除了<em>重写</em>之外，可以使用<em>加锁-复制技术</em>：在调用该函数时加锁，然后把结果拷贝到私有地址上，然后释放。这种技术有一些缺点，比如<em>加锁降低效率</em>、<em>如果返回了一个链表之类的东西你需要深复制整个链表</em>。</li>
<li><strong>调用线程不安全的函数</strong>。如果调用第二类不安全函数，那么就没什么救。否则可以调用前加锁，加锁之后就还是线程安全的。</li>
</ol>
<p><strong>可重入函数</strong>是线程安全的。其定义是在被任意多个线程调用时都不会有共享变量。可以进一步分成两类：</p>
<ul>
<li><em>显式可重入：</em>通过值传参，而且只有局部变量。</li>
<li><em>隐式可重入：</em>传参可以用指针。此时如果你传参足够小心，就确实还是可重入。</li>
</ul>
<p>大部分 Linux 函数都是线程安全的，包括 <code>malloc</code>，<code>free</code>，<code>realloc</code>，<code>printf</code>，<code>scanf</code> 等。</p>
<p><code>rand</code> 和 <code>strtok</code>（不知道是干什么的）属于第二类线程不安全函数。其他还有一些 <code>ctime</code>，<code>asctime</code>，<code>localtime</code> 和一堆 <code>gethostbyname</code>，<code>gethostbyaddr</code>，<code>inet_ntoa</code> 之类的网络编程函数是第三类线程不安全函数。</p>
<hr>
<p>接下来讲两类资源调度问题。</p>
<p><strong>生产者-消费者问题</strong></p>
<p>生产者线程往一个缓冲区里面写东西，消费者线程从缓冲区拿东西出来处理。有如下限制：</p>
<ul>
<li>不能并发读写。</li>
<li>缓冲区满时生产者不能写。</li>
<li>缓冲区空时消费者不能读。</li>
</ul>
<p>思路是在信号量里面存<em>空闲块的数量</em>和<em>待处理块的数量</em>。（<code>sbuf_init</code> 是一个带有三个信号量的循环队列，这里我们只考察信号量）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Sem_init(&amp;sf-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  Sem_init(&amp;sf-&gt;slots, <span class="number">0</span>, n);</span><br><span class="line">  Sem_init(&amp;sf-&gt;items, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span> &#123;</span><br><span class="line">  P(&amp;sp-&gt;slots);</span><br><span class="line">  P(&amp;sp-&gt;mutex);</span><br><span class="line">  <span class="comment">// insert item into the queue</span></span><br><span class="line">  V(&amp;sp-&gt;mutex);</span><br><span class="line">  V(&amp;sp-&gt;items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span> &#123;</span><br><span class="line">  <span class="type">int</span> item;</span><br><span class="line">  P(&amp;sp-&gt;items);</span><br><span class="line">  P(&amp;sp-&gt;mutex);</span><br><span class="line">  <span class="comment">// item = queue.front()</span></span><br><span class="line">  V(&amp;sp-&gt;mutex);</span><br><span class="line">  V(&amp;sp-&gt;slots);</span><br><span class="line">  <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务器问题中可以抽象出一个生产者-消费者问题。每次 <code>accept</code> 一个新的 <code>connfd</code> 就往缓冲区写一个 <code>connfd</code>。然后一些线程作为消费者来处理这些 <code>connfd</code>。这样的优化叫做<strong>预线程化</strong>，优化了每次连接时开新线程的时间。</p>
<hr>
<p><strong>读者-写者问题</strong></p>
<p>这是对 CREW 问题的一种抽象。要求</p>
<ul>
<li>读者可以同时读。</li>
<li>写者在写时必须控制整个缓冲区。</li>
</ul>
<p>有两种变种，一类是读者优先（除非写者正在写，不能让读者等待），一类是写者优先。我们讨论读者优先，写者优先是对称的。</p>
<p>只需要维护正在读的读者数量 <code>readcnt</code> 和刻画写者权限的信号量 <code>w</code>。一旦 <code>readcnt &gt; 0</code>，就 $P(w)$。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">  P(&amp;mutex); <span class="comment">// 注意这里需要锁上，不然有竞争</span></span><br><span class="line">  readcnt++;</span><br><span class="line">  <span class="keyword">if</span>(readcnt == <span class="number">1</span>) P(&amp;w);</span><br><span class="line">  V(&amp;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里读</span></span><br><span class="line"></span><br><span class="line">  P(&amp;mutex);</span><br><span class="line">  readcnt--;</span><br><span class="line">  <span class="keyword">if</span>(readcnt == <span class="number">0</span>) V(&amp;w);</span><br><span class="line">  V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">  P(&amp;w);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里写</span></span><br><span class="line"></span><br><span class="line">  V(&amp;w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linking/" rel="tag"># Linking</a>
              <a href="/tags/Eception-Control-Flow/" rel="tag"># Eception Control Flow</a>
              <a href="/tags/Virtual-Memory/" rel="tag"># Virtual Memory</a>
              <a href="/tags/System-Level-IO/" rel="tag"># System Level IO</a>
              <a href="/tags/Network/" rel="tag"># Network</a>
              <a href="/tags/Concurrent-Programming/" rel="tag"># Concurrent Programming</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/12/18/QuantumLSMR/" rel="prev" title="Qisheng Wang, Mingsheng Ying. Quantum Algorithm for Lexicographically Minimal String Rotation (2022)">
                  <i class="fa fa-angle-left"></i> Qisheng Wang, Mingsheng Ying. Quantum Algorithm for Lexicographically Minimal String Rotation (2022)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/01/11/CS285DRLI/" rel="next" title="CS285 Deep Reinforcement Learning 学习笔记">
                  CS285 Deep Reinforcement Learning 学习笔记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">King Strange</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
